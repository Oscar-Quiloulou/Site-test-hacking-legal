<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>50 Cubes qui tournent — Three.js</title>
  <style>
    html,body{height:100%;margin:0;background:#0b0b0f;overflow:hidden}
    #ui{position:fixed;left:12px;top:12px;z-index:2;color:#eee;font-family:Inter,Arial,sans-serif}
    .panel{background:rgba(0,0,0,0.35);backdrop-filter:blur(6px);padding:8px;border-radius:8px}
    label{display:block;font-size:13px;margin-bottom:6px}
    input[type=range]{width:180px}
    a.small{color:#9bdcff;text-decoration:none;font-size:12px}
  </style>
</head>
<body>
  <div id="ui" class="panel">
    <label>Vitesse globale : <span id="speedVal">3.0</span></label>
    <input id="speed" type="range" min="0" max="10" step="0.1" value="3">
    <div style="margin-top:8px;font-size:12px;color:#cfcfcf">Cubes : <span id="countVal">50</span></div>
    <input id="count" type="range" min="1" max="20000" step="1" value="50">
    <div style="margin-top:8px"><a class="small" href="#" id="regen">Régénérer</a> • <a class="small" href="https://oscar-quiloulou.github.io/Site-test-hacking-legal/" target="_blank">ouvrir ton site</a></div>
  </div>

  <!-- Important: use an import map so that the example modules which import from "three" resolve correctly in the browser -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.module.js"
    }
  }
  </script>

  <!-- Module script: imports will now resolve 'three' via the import map -->
  <script type="module">
    // Importing 'three' via the import map ensures example modules (which use the bare specifier 'three') resolve correctly.
    import * as THREE from 'three';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.155.0/examples/jsm/controls/OrbitControls.js';

    // Setup basique
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 12);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // Lumières
    const amb = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(amb);
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(5,10,7);
    scene.add(dir);

    // Contrôles (OrbitControls importé via module + import map)
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.12;

    // Groupe pour contenir les cubes
    let cubesGroup = new THREE.Group();
    scene.add(cubesGroup);

    // UI
    const distanceInput = document.createElement('input');
    distanceInput.type = 'range';
    distanceInput.min = '1';
    distanceInput.max = '20';
    distanceInput.step = '0.1';
    distanceInput.value = '7.5';
    const distanceLabel = document.createElement('label');
    distanceLabel.textContent = 'Distance cubes : ';
    const distanceVal = document.createElement('span');
    distanceVal.id = 'distanceVal';
    distanceVal.textContent = distanceInput.value;
    distanceLabel.appendChild(distanceVal);
    document.getElementById('ui').appendChild(distanceLabel);
    document.getElementById('ui').appendChild(distanceInput);

    // --- Sliders gravité sous Distance ---
    const gravLabel = document.createElement('label'); gravLabel.textContent = 'Gravité : ';
    const gravVal = document.createElement('span'); gravVal.id = 'gravVal'; gravVal.textContent = '9.8';
    gravLabel.appendChild(gravVal);
    const gravInput = document.createElement('input');
    gravInput.type = 'range'; gravInput.min = '0'; gravInput.max = '30'; gravInput.step = '0.1'; gravInput.value = '9.8';
    document.getElementById('ui').appendChild(gravLabel);
    document.getElementById('ui').appendChild(gravInput);

    const bounceLabel = document.createElement('label'); bounceLabel.textContent = 'Rebond : ';
    const bounceVal = document.createElement('span'); bounceVal.id = 'bounceVal'; bounceVal.textContent = '0.45';
    bounceLabel.appendChild(bounceVal);
    const bounceInput = document.createElement('input');
    bounceInput.type = 'range'; bounceInput.min = '0'; bounceInput.max = '1'; bounceInput.step = '0.01'; bounceInput.value = '0.45';
    document.getElementById('ui').appendChild(bounceLabel);
    document.getElementById('ui').appendChild(bounceInput);

    const groundLabel = document.createElement('label'); groundLabel.textContent = 'Sol Y : ';
    const groundVal = document.createElement('span'); groundVal.id = 'groundVal'; groundVal.textContent = '-6';
    groundLabel.appendChild(groundVal);
    const groundInput = document.createElement('input');
    groundInput.type = 'range'; groundInput.min = '-20'; groundInput.max = '5'; groundInput.step = '0.1'; groundInput.value = '-6';
    document.getElementById('ui').appendChild(groundLabel);
    document.getElementById('ui').appendChild(groundInput);

    let gravity = parseFloat(gravInput.value);
    let bounce = parseFloat(bounceInput.value);
    let groundY = parseFloat(groundInput.value);

    gravInput.addEventListener('input', e=>{ gravity = parseFloat(e.target.value); gravVal.textContent = gravity.toFixed(1); });
    bounceInput.addEventListener('input', e=>{ bounce = parseFloat(e.target.value); bounceVal.textContent = bounce.toFixed(2); });
    groundInput.addEventListener('input', e=>{ groundY = parseFloat(e.target.value); groundVal.textContent = groundY.toFixed(1); });

    let cubeDistance = parseFloat(distanceInput.value);
    distanceInput.addEventListener('input', (e) => {
      cubeDistance = parseFloat(e.target.value);
      distanceVal.textContent = cubeDistance.toFixed(1);
      createCubes(parseInt(countInput.value));
    });
    const speedInput = document.getElementById('speed');
    const speedVal = document.getElementById('speedVal');
    const countInput = document.getElementById('count');
    const countVal = document.getElementById('countVal');
    const regen = document.getElementById('regen');

    let speedMul = parseFloat(speedInput.value);
    speedVal.textContent = speedMul.toFixed(1);
    countVal.textContent = countInput.value;

    speedInput.addEventListener('input', (e)=>{ speedMul = parseFloat(e.target.value); speedVal.textContent = speedMul.toFixed(1); });
    countInput.addEventListener('input', (e)=>{ countVal.textContent = e.target.value; });
    regen.addEventListener('click', (e)=>{ e.preventDefault(); createCubes(parseInt(countInput.value)); });

    // Fonction utilitaire couleur aléatoire
    function randColor(){
      const h = Math.random();
      const s = 0.6 + Math.random()*0.4;
      const l = 0.45 + Math.random()*0.25;
      return new THREE.Color().setHSL(h,s,l);
    }

    // Crée les cubes
    function createCubes(n=50){
      // Vide le groupe
      while(cubesGroup.children.length) cubesGroup.remove(cubesGroup.children[0]);

      const geo = new THREE.BoxGeometry(1,1,1);

      for(let i=0;i<n;i++){
        const mat = new THREE.MeshStandardMaterial({color: randColor(), metalness: 0.3, roughness: 0.4});
        const m = new THREE.Mesh(geo, mat);

        // Positionnement aléatoire dans une sphère / volume
        const radius = cubeDistance;
        const phi = Math.acos(2*Math.random()-1);
        const theta = Math.random()*Math.PI*2;
        const r = Math.pow(Math.random(),1/3)*radius; // distribution uniforme du volume
        m.position.set(
          Math.sin(phi)*Math.cos(theta)*r,
          Math.sin(phi)*Math.sin(theta)*r*0.6, // un peu aplati
          Math.cos(phi)*r
        );

        // Echelle et rotation initiale
        const scale = 0.35 + Math.random()*1.2;
        m.scale.set(scale, scale, scale);
        m.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);

        // Vitesse de rotation propre
        m.userData = {
          rx: (0.8 + Math.random()*6.5) * (Math.random()<0.5 ? -1 : 1),
          ry: (0.8 + Math.random()*6.5) * (Math.random()<0.5 ? -1 : 1),
          rz: (0.8 + Math.random()*6.5) * (Math.random()<0.5 ? -1 : 1)
        };

        cubesGroup.add(m);
      }
    }

    // Initial
    createCubes(parseInt(countInput.value));

    // Respawn automatique si la fenêtre change
    window.addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // Animation
    const clock = new THREE.Clock();
    let paused = false;
    function animate(){
      requestAnimationFrame(animate);

      const dt = paused ? 0 : clock.getDelta();

      if(!paused){
        // faire tourner chaque cube vite
        cubesGroup.children.forEach(c=>{
          c.rotation.x += c.userData.rx * dt * 0.6 * speedMul;
          c.rotation.y += c.userData.ry * dt * 0.6 * speedMul;
          c.rotation.z += c.userData.rz * dt * 0.6 * speedMul;
        });

        // rotation de groupe pour un effet global
        cubesGroup.rotation.y += 0.1 * dt * speedMul;
      }

      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // Astuce : appuyer sur espace pour mettre en pause
    window.addEventListener('keydown', (e)=>{
      if(e.code === 'Space'){
        paused = !paused;
        // réinitialiser l'horloge pour éviter un gros dt quand on reprend
        if(!paused) clock.getDelta();
      }
    });

  </script>
</body>
</html>
